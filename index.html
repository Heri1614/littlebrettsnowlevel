<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>LittleBrett Game</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      height: 100%;
      background-color: black;
    }
    canvas {
      display: block;
      width: 100vw;
      height: 100vh;
    }
    #startButton {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 25vw;
      max-width: 300px;
      z-index: 10;
      cursor: pointer;
    }
  </style>
</head>
<body>

  <img id="startButton" src="btn_start.png" alt="Start" disabled>
  <canvas id="gameCanvas"></canvas>
  <img id="invokeButton" src="invoke_btn.png" style="display: none; position: absolute; bottom: 20px; left: 20px; width: 70px; cursor: pointer; z-index: 20;">

  <script>
    const startButton = document.getElementById('startButton');
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    const bgForest = new Image();
    bgForest.src = 'bg_forest.png';

    const brettIdle = new Image(); brettIdle.src = 'brett_idle.png';
    const brettWalk = new Image(); brettWalk.src = 'brett_walk1.png';
    const brettJump = new Image(); brettJump.src = 'brett_jump.png';
    const brettFall = new Image(); brettFall.src = 'brett_fall.png';
    const bullFire = new Image(); bullFire.src = 'bull_fire.png';

    const enemy = {
      x: 400, y: 460, width: 50, height: 60, speed: 2.5, direction: 1,
      alive: true, exploding: false, explosionTimer: 0,
      img: new Image()
    };
    enemy.img.src = 'enemy1.png';

    const explosionImg = new Image();
    explosionImg.src = 'explosion.png';
    let explosionLoaded = false;
    explosionImg.onload = () => {
      explosionLoaded = true;
      startButton.disabled = false;  // ‚úÖ Activar bot√≥n cuando la imagen est√© cargada
    };

   const coins = [
  { "x": 245, "y": 370, "type": "btc", "value": 50, "collected": false },
  { "x": 345, "y": 370, "type": "eth", "value": 30, "collected": false },
  { "x": 445, "y": 370, "type": "coin", "value": 20, "collected": false },
  { "x": 545, "y": 370, "type": "btc", "value": 50, "collected": false },
  { "x": 645, "y": 370, "type": "eth", "value": 30, "collected": false },
  { "x": 745, "y": 370, "type": "coin", "value": 20, "collected": false },
  { "x": 845, "y": 370, "type": "btc", "value": 50, "collected": false },
  { "x": 945, "y": 370, "type": "eth", "value": 30, "collected": false },
  { "x": 1045, "y": 370, "type": "coin", "value": 20, "collected": false },
  { "x": 1145, "y": 370, "type": "btc", "value": 50, "collected": false },
  // ... agrega los siguientes hasta completar 50
];


    const coinImages = {
      coin: new Image(),
      eth: new Image(),
      btc: new Image()
    };
    coinImages.coin.src = 'coin.png';
    coinImages.eth.src = 'eth.png';
    coinImages.btc.src = 'btc.png';

    let score = 0;
    let bullActive = false;
    let bullX = -200;
    let bullSpeed = 15;
    let bullCharges = 0; // ‚úÖ Inicializamos la variable para controlar las cargas del toro
    const invokeButton = document.getElementById('invokeButton');

    function checkInvokeButton() {
  invokeButton.style.display = bullCharges > 0 ? 'block' : 'none';
}

    invokeButton.onclick = () => {
  if (!bullActive && bullCharges > 0) {
    bullActive = true;
    bullX = -200;
    bullCharges--; // Gastamos una carga
    console.log(`üêÇ Toro invocado. Cargas restantes: ${bullCharges}`);
  }
};

   const platforms = [];
const platformCount = 50;
let x = 200;
let y = 400;
let direction = -1;

for (let i = 0; i < platformCount; i++) {
  platforms.push({
    x: x,
    y: y,
    width: 120,
    height: 20,
    img: "Platform_small.png",
    type: "normal"
  });

  x += 130; // avanzamos horizontalmente
  y += direction * 40; // sube o baja cada vez

  // Cambia de direcci√≥n cada 4 plataformas
  if (i % 4 === 0) {
    direction *= -1;
  }

  // l√≠mite vertical razonable (no demasiado arriba ni abajo)
  if (y < 200) y = 200;
  if (y > 450) y = 450;
}

    const platforms = [];
const platformCount = 50;
let x = 200;
let y = 400;
let direction = -1;

for (let i = 0; i < platformCount; i++) {
  const isLog = i % 5 === 0; // cada 5 plataformas una ser√° log
  platforms.push({
    x: x,
    y: y,
    width: 120,
    height: 20,
    img: isLog ? "log.png" : "Platform_small.png",
    type: isLog ? "log" : "normal",
    triggered: false,
    timer: 0
  });

  x += 130; // avanza horizontalmente
  y += direction * 40; // sube o baja

  if (i % 4 === 0) direction *= -1; // zig-zag

  if (y < 200) y = 200;
  if (y > 450) y = 450;
}

const platformImages = {};
for (const p of platforms) {
  if (!platformImages[p.img]) {
    platformImages[p.img] = new Image();
    platformImages[p.img].src = p.img;
  }
}

    let currentSprite = brettIdle;
    let brettX = 400, brettY = 380, velocityY = 0;
    let isJumping = false, isFalling = false;
    let moveLeft = false, moveRight = false;
    let gameStarted = false;

    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      if (gameStarted) drawGame();
    }

    window.addEventListener('resize', resizeCanvas);

    startButton.onclick = () => {
      gameStarted = true;
      startButton.style.display = 'none';
      resizeCanvas();
      gameLoop();
    };

    function drawGame() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.drawImage(bgForest, 0, 0, canvas.width, canvas.height);

      for (const p of platforms) {
        if (p.type === 'log' && p.triggered && p.timer > 120) continue;
        ctx.drawImage(platformImages[p.img], p.x, p.y, p.width, p.height);
      }

      for (const c of coins) {
        if (!c.collected) {
          ctx.drawImage(coinImages[c.type], c.x, c.y, 30, 30);
        }
      }

      ctx.fillStyle = 'white';
      ctx.font = '24px Arial';
      ctx.fillText(`Score: ${score}`, 20, 40);

      const brettWidth = canvas.width * 0.1;
      const brettHeight = brettWidth;

      if (isJumping) {
        currentSprite = velocityY < 0 ? brettJump : brettFall;
      } else if (moveLeft || moveRight) {
        currentSprite = brettWalk;
      } else {
        currentSprite = brettIdle;
      }

      ctx.drawImage(currentSprite, brettX, brettY, brettWidth, brettHeight);

      if (bullActive) {
        const bullY = canvas.height - 140;
        ctx.drawImage(bullFire, bullX, bullY, 150, 100);
      }

      if (enemy.alive) {
        ctx.drawImage(enemy.img, enemy.x, enemy.y, enemy.width, enemy.height);
      } else if (enemy.exploding && enemy.explosionTimer > 0) {
        console.log("üî• DIBUJANDO EXPLOSION");
        const explosionX = enemy.x + (enemy.width / 2) - 50;
        const explosionY = enemy.y + (enemy.height / 2) - 50;
        ctx.drawImage(explosionImg, explosionX, explosionY, 100, 100);
        ctx.fillStyle = 'red';
        ctx.fillRect(explosionX + 10, explosionY + 10, 10, 10);
      }
    }

    function gameLoop() {
      const speed = 5;
      const gravity = 1.2;
      const brettWidth = canvas.width * 0.1;
      const brettHeight = brettWidth;

      if (moveLeft) brettX -= speed;
      if (moveRight) brettX += speed;
      brettX = Math.max(0, Math.min(canvas.width - brettWidth, brettX));
      velocityY += gravity;
      brettY += velocityY;

      let onPlatform = false;

      for (const p of platforms) {
        if (p.type === 'log') {
          if (p.triggered) {
            p.timer++;
            if (p.timer > 120 && p.timer <= 360) continue;
            if (p.timer > 360) {
              p.triggered = false;
              p.timer = 0;
            }
          }
        }

        const footY = brettY + brettHeight;
        const onTop = brettX + brettWidth > p.x && brettX < p.x + p.width && footY >= p.y && footY <= p.y + 20 && velocityY >= 0;

        if (onTop) {
          brettY = p.y - brettHeight;
          velocityY = 0;
          isJumping = false;
          onPlatform = true;
          if (p.type === 'log' && !p.triggered) {
            p.triggered = true;
            p.timer = 0;
          }
        }
      }

      const groundY = canvas.height - brettHeight - 20;
      if (brettY >= groundY) {
        brettY = groundY;
        velocityY = 0;
        isJumping = false;
        onPlatform = true;
      }

      if (!onPlatform) isJumping = true;

      for (const c of coins) {
        if (!c.collected) {
          const brettRight = brettX + brettWidth;
          const brettBottom = brettY + brettHeight;
          const colX = brettRight > c.x && brettX < c.x + 30;
          const colY = brettBottom > c.y && brettY < c.y + 30;

         if (colX && colY) {
  c.collected = true;
  const previousScore = score;
  score += c.value;

  // Verificar si se alcanz√≥ una nueva carga del toro
  const previousCharges = Math.floor(previousScore / 100);
  const newCharges = Math.floor(score / 100);
  const gainedCharges = newCharges - previousCharges;

  if (gainedCharges > 0) {
    bullCharges += gainedCharges;
    console.log(`üî• Toro recargado +${gainedCharges} (total: ${bullCharges})`);
  }
}
        }
      }

      if (enemy.alive) {
        enemy.x += enemy.speed * enemy.direction;
        if (enemy.x + enemy.width >= canvas.width) enemy.direction = -1;
        if (enemy.x <= 400) enemy.direction = 1;
      }

      if (bullActive) {
        bullX += bullSpeed;
        if (enemy.alive) {
          const bullY = canvas.height - 140;
          const bullWidth = 150;
          const bullHeight = 100;

          const bullRight = bullX + bullWidth;
          const bullBottom = bullY + bullHeight;

          const enemyRight = enemy.x + enemy.width;
          const enemyBottom = enemy.y + enemy.height;

          const colX = bullRight > enemy.x && bullX < enemyRight;
          const colY = bullBottom > enemy.y && bullY < enemyBottom;

          if (colX && colY && !enemy.exploding) {
            enemy.exploding = true;
            enemy.explosionTimer = 90;
            enemy.alive = false;
            console.log("¬°Enemigo destruido por el toro!");
          }
        }
      }

      if (bullX > canvas.width) {
        bullActive = false;
        bullX = -200;
      }

      if (enemy.exploding && enemy.explosionTimer > 0) {
        enemy.explosionTimer--;
      }

      checkInvokeButton();
      drawGame();
      requestAnimationFrame(gameLoop);
    }

    window.addEventListener('keydown', (e) => {
      if (!gameStarted) return;
      if (e.key === 'ArrowLeft' || e.key === 'a') moveLeft = true;
      if (e.key === 'ArrowRight' || e.key === 'd') moveRight = true;
      if ((e.key === ' ' || e.key === 'w') && !isJumping) {
        isJumping = true;
        velocityY = -18;
      }
    });

    window.addEventListener('keyup', (e) => {
      if (e.key === 'ArrowLeft' || e.key === 'a') moveLeft = false;
      if (e.key === 'ArrowRight' || e.key === 'd') moveRight = false;
    });

    window.addEventListener('keydown', (e) => {
      if (e.key === 'e') {
        ctx.drawImage(explosionImg, 300, 300, 100, 100);
        console.log('Explosi√≥n manual dibujada');
      }
    });
  </script>
</body>
</html>
