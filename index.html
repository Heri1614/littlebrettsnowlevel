<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>LittleBrett Platformer</title>
  <style>
    /* Estilos generales */
    html, body { margin: 0; padding: 0; overflow: hidden; background: #000; }
    canvas { display: block; }

    /* Botón de inicio */
    #startBtn {
      position: absolute;
      top: 50%; left: 50%;
      transform: translate(-50%, -50%);
      z-index: 2;
      padding: 20px 40px;
      font-size: 24px;
      cursor: pointer;
      display: none; /* oculto hasta que carguen imágenes */
      /* Si btn_start.png está disponible, usarla de fondo */
      background: url('btn_start.png') no-repeat center center;
      background-size: contain;
      color: white; /* texto visible si imagen no carga */
      border: none;
    }

    /* Controles táctiles */
    .ctrlBtn {
      position: absolute;
      bottom: 10px;
      width: 60px; height: 60px;
      opacity: 0.8;
      z-index: 2;
      touch-action: none; /* desactiva gesto por defecto */
      display: none;      /* se muestra al iniciar juego */
    }
    #leftBtn  { left: 10px; }
    #rightBtn { left: 80px; } /* separado ~70px del leftBtn */
    #jumpBtn  { right: 10px; }
  </style>
</head>
<body>
  <!-- Canvas del juego -->
  <canvas id="gameCanvas"></canvas>

  <!-- Botón de inicio -->
  <button id="startBtn">PLAY GAME</button>

  <!-- Botones de control táctil -->
  <img id="leftBtn" class="ctrlBtn" src="btn_left.png" alt="Left" />
  <img id="rightBtn" class="ctrlBtn" src="btn_right.png" alt="Right" />
  <img id="jumpBtn" class="ctrlBtn" src="btn_jump.png" alt="Jump" />

  <script>
    "use strict";
    (function(){
      const canvas = document.getElementById('gameCanvas');
      const ctx = canvas.getContext('2d');
      // Hacer canvas del tamaño de la ventana
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;

      // Variables de juego
      let gameState = 'init'; // 'init', 'running', 'gameover', 'victory'
      let score = 0;

      // Objeto jugador (LittleBrett)
      const player = {
        x: 0, y: 0,
        width: 50, height: 50,  // se ajustará tras cargar sprites
        vx: 0, vy: 0,
        speed: 5,              // velocidad horizontal
        jumpForce: 15,         // intensidad del salto
        grounded: false,       // está sobre una plataforma
        direction: 1,          // 1 = mirando derecha, -1 = izquierda
        currentImage: null     // imagen actual para dibujar
      };

      // Mundo del juego
      let gravity = 0.8;
      let platforms = [];  // plataformas (objetos con x, y, width, height, img)
      let coins = [];      // monedas (objetos con x, y, size, img, collected)
      let cameraOffsetY = 0;
      let baselineY;       // altura (y) de la plataforma inicial (piso)

      // Carga de imágenes
      const images = {};
      const imageSources = {
        bg:          'bg_forest.png',
        brett_idle:  'brett_idle.png',
        brett_walk:  'brett_walk1.png',
        brett_jump:  'brett_jump.png',
        brett_fall:  'brett_fall.png',
        brett_down:  'brett_down.png',
        brett_happy: 'brett_happy.png',
        platform1:   'platform_ice.png',
        platform2:   'platform_tall.png',
        platform3:   'platform_small.png',
        coin1:       'coin.png',
        coin2:       'eth.png',
        coin3:       'btc.png'
      };
      let loadedCount = 0;
      const totalImages = Object.keys(imageSources).length;
      // Precargar todas las imágenes
      for (let key in imageSources) {
        images[key] = new Image();
        images[key].src = imageSources[key];
        images[key].onload = function() {
          loadedCount++;
          if (loadedCount === totalImages) {
            // Iniciar juego una vez cargadas todas las imágenes
            initGame();
          }
        };
        images[key].onerror = function() {
          console.error("Error cargando imagen:", imageSources[key]);
          loadedCount++;
          if (loadedCount === totalImages) {
            initGame();
          }
        };
      }

      // Inicializar juego (crear plataformas, ubicar jugador) después de carga
      function initGame() {
        // Plataforma inicial (piso) centrada en la parte inferior
        baselineY = canvas.height - 80;  // 80px desde el fondo
        const platformWidth = 120;
        const platformHeight = 20;
        platforms = [];
        // Añadir plataforma de inicio
        platforms.push({
          x: (canvas.width - platformWidth) / 2,
          y: baselineY,
          width: platformWidth,
          height: platformHeight,
          img: images.platform1  // usar platform_ice como base
        });
        // Colocar al jugador sobre la plataforma inicial
        player.width = images.brett_idle.width;
        player.height = images.brett_idle.height;
        player.x = platforms[0].x + (platforms[0].width / 2) - (player.width / 2);
        player.y = platforms[0].y - player.height;
        player.vx = 0;
        player.vy = 0;
        player.grounded = true;
        player.currentImage = images.brett_idle;

        // Generar plataformas adicionales arriba
        let currentY = baselineY;
        const minGap = 60, maxGap = 120;
        const platformCount = 40;
        for (let i = 1; i < platformCount; i++) {
          // Calcular separación vertical aleatoria
          const gap = Math.floor(Math.random() * (maxGap - minGap + 1)) + minGap;
          currentY -= gap;
          // Variar aleatoriamente el ancho de la plataforma un poco
          let platWidth = platformWidth + (Math.random() * 50 - 25);
          if (platWidth < 80) platWidth = 80;
          if (platWidth > 180) platWidth = 180;
          // Elegir posición X cerca de la plataforma anterior
          const prevX = platforms[i-1].x;
          const maxOffset = 150;
          let platX = prevX + (Math.random() * 2 - 1) * maxOffset;
          if (platX < 0) platX = 0;
          if (platX + platWidth > canvas.width) {
            platX = canvas.width - platWidth;
          }
          // Seleccionar imagen de plataforma aleatoriamente
          let pImg;
          const typeRand = Math.random();
          if (typeRand < 0.33) pImg = images.platform1;
          else if (typeRand < 0.66) pImg = images.platform2;
          else pImg = images.platform3;
          // Crear objeto plataforma
          platforms.push({
            x: platX,
            y: currentY,
            width: platWidth,
            height: platformHeight,
            img: pImg
          });
        }

        // Generar monedas en algunas plataformas
        coins = [];
        for (let i = 1; i < platforms.length; i++) {  // (opcional: omitir plataforma 0 para no poner moneda en el piso inicial)
          if (Math.random() < 0.3) {  // 30% de probabilidad
            // Elegir tipo de moneda aleatoriamente
            let coinImg;
            const r = Math.random();
            if (r < 0.33) coinImg = images.coin1;
            else if (r < 0.66) coinImg = images.coin2;
            else coinImg = images.coin3;
            // Calcular tamaño (usar ancho de la imagen si está cargada)
            let coinSize = coinImg.width || 24;
            // Ubicar coin centrada horizontalmente sobre la plataforma
            const coinX = platforms[i].x + (platforms[i].width / 2) - (coinSize / 2);
            const coinY = platforms[i].y - coinSize - 5;
            // Crear objeto moneda
            coins.push({ x: coinX, y: coinY, size: coinSize, img: coinImg, collected: false });
          }
        }

        // Mostrar botón de inicio ahora que todo está listo
        document.getElementById('startBtn').style.display = 'block';
      }

      // Iniciar la partida (al hacer click en Play)
      function startGame() {
        gameState = 'running';
        // Ocultar botón de inicio y mostrar controles
        document.getElementById('startBtn').style.display = 'none';
        document.querySelectorAll('.ctrlBtn').forEach(btn => btn.style.display = 'block');
        // Comenzar bucle de juego
        requestAnimationFrame(gameLoop);
      }

      // Bucle principal del juego
      function gameLoop() {
        if (gameState === 'running') {
          updateGame();
          renderGame();
          requestAnimationFrame(gameLoop);
        } else {
          // Si juego terminado (gameover o victory), dibujar último frame
          renderGame();
          // (Podríamos aquí volver a mostrar botón de reinicio, etc.)
        }
      }

      // Actualizar lógica del juego (física, colisiones, etc.)
      function updateGame() {
        // Movimiento horizontal por input
        if (leftPressed) {
          player.vx = -player.speed;
          player.direction = -1;
        } else if (rightPressed) {
          player.vx = player.speed;
          player.direction = 1;
        } else {
          player.vx = 0;
        }

        // Aplicar gravedad al personaje
        player.vy += gravity;
        if (player.vy > 20) player.vy = 20;  // velocidad máxima de caída

        // Mover horizontalmente (y limitar dentro de pantalla)
        player.x += player.vx;
        if (player.x < 0) {
          player.x = 0;
        } else if (player.x + player.width > canvas.width) {
          player.x = canvas.width - player.width;
        }

        // Mover verticalmente
        player.y += player.vy;

        // Verificar colisión con plataformas (aterrizaje)
        if (player.vy >= 0) {  // solo checar cuando cae o está quieto (no subiendo)
          for (let plat of platforms) {
            if (
              player.x + player.width > plat.x &&      // colisión en X
              player.x < plat.x + plat.width &&
              player.y + player.height > plat.y &&     // colisión en Y
              player.y + player.height - player.vy <= plat.y  // estaba por encima en el frame anterior
            ) {
              // Aterriza sobre la plataforma
              player.y = plat.y - player.height;  // ajustar en la superficie
              player.vy = 0;
              player.grounded = true;
              break;
            }
          }
        }

        // Si después de mover, el jugador no está tocando ninguna plataforma, está en el aire
        if (player.vy !== 0) {
          player.grounded = false;
        }

        // Recolección de monedas
        for (let coin of coins) {
          if (!coin.collected) {
            if (
              player.x < coin.x + coin.size &&
              player.x + player.width > coin.x &&
              player.y < coin.y + coin.size &&
              player.y + player.height > coin.y
            ) {
              // Toca una moneda
              coin.collected = true;
              score += 1;
            }
          }
        }

        // Movimiento de cámara: seguir al jugador al subir
        const cameraMargin = canvas.height * 0.3;  // margen desde arriba
        if (player.y < cameraMargin) {
          // Desplazar cámara hacia arriba (aumentar offset)
          const diff = cameraMargin - player.y;
          cameraOffsetY += diff;
          // Fijar al jugador en el margen (como si cámara lo siguiera)
          player.y = cameraMargin;
        }
        // No bajar cámara debajo del nivel inicial
        if (cameraOffsetY < 0) {
          cameraOffsetY = 0;
        }

        // Comprobar victoria (llegó al final del nivel)
        const lastPlat = platforms[platforms.length - 1];
        if (player.y + cameraOffsetY <= lastPlat.y - 50) {
          gameState = 'victory';
          player.currentImage = images.brett_happy;
        }

        // Comprobar caída al vacío (game over)
        if (player.y + player.height > canvas.height) {
          gameState = 'gameover';
          // Mostrar sprite de derrota y posicionar en el borde inferior
          player.y = canvas.height - player.height;
          player.currentImage = images.brett_down;
        }

        // Actualizar sprite del jugador según estado
        if (gameState === 'running') {
          if (!player.grounded) {
            // En el aire
            if (player.vy < 0) {
              player.currentImage = images.brett_jump;
            } else {
              player.currentImage = images.brett_fall;
            }
          } else {
            // En tierra
            if (player.vx !== 0) {
              player.currentImage = images.brett_walk;
            } else {
              player.currentImage = images.brett_idle;
            }
          }
        }
      }

      // Renderizar/dibujar el juego en cada frame
      function renderGame() {
        // Limpiar canvas
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Dibujar fondo (ajustado a pantalla completa)
        const bgImg = images.bg;
        if (bgImg && bgImg.complete) {
          // Calcular escala para cubrir todo
          const scale = Math.max(canvas.width / bgImg.width, canvas.height / bgImg.height);
          const bgW = bgImg.width * scale;
          const bgH = bgImg.height * scale;
          const bgX = (canvas.width - bgW) / 2;
          const bgY = (canvas.height - bgH) / 2;
          // Dibujar fondo (con desplazamiento de cámara)
          ctx.save();
          ctx.translate(0, -cameraOffsetY);
          ctx.drawImage(bgImg, bgX, bgY, bgW, bgH);
          ctx.restore();
        } else {
          // Color de fondo de reserva si imagen no disponible
          ctx.fillStyle = '#4a8';
          ctx.fillRect(0, 0, canvas.width, canvas.height);
        }

        // Dibujar plataformas
        ctx.fillStyle = '#ccc';
        for (let plat of platforms) {
          const drawX = plat.x;
          const drawY = plat.y - cameraOffsetY;
          // Omitir dibujo si plataforma está fuera de la pantalla actual
          if (drawY > canvas.height || drawY + plat.height < 0) continue;
          if (plat.img && plat.img.complete) {
            ctx.drawImage(plat.img, drawX, drawY);
          } else {
            // rectángulo gris si imagen no cargó
            ctx.fillRect(drawX, drawY, plat.width, plat.height);
          }
        }

        // Dibujar monedas
        for (let coin of coins) {
          if (coin.collected) continue;  // no dibujar si ya tomada
          const drawX = coin.x;
          const drawY = coin.y - cameraOffsetY;
          if (drawY > canvas.height || drawY + coin.size < 0) continue;
          if (coin.img && coin.img.complete) {
            ctx.drawImage(coin.img, drawX, drawY);
          } else {
            // círculo amarillo si imagen no disponible
            ctx.fillStyle = 'yellow';
            ctx.beginPath();
            ctx.arc(drawX + coin.size/2, drawY + coin.size/2, coin.size/2, 0, 2*Math.PI);
            ctx.fill();
          }
        }

        // Dibujar jugador (con orientación correcta)
        const playerDrawX = player.x;
        const playerDrawY = player.y - cameraOffsetY;
        const sprite = player.currentImage;
        if (sprite && sprite.complete) {
          ctx.save();
          if (player.direction === -1) {
            // Voltear sprite a la izquierda
            ctx.translate(playerDrawX + player.width/2, 0);
            ctx.scale(-1, 1);
            ctx.drawImage(sprite, -player.width/2, playerDrawY, player.width, player.height);
          } else {
            ctx.drawImage(sprite, playerDrawX, playerDrawY, player.width, player.height);
          }
          ctx.restore();
        } else {
          // Dibujar un rectángulo placeholder si sprite no cargado
          ctx.fillStyle = 'blue';
          ctx.fillRect(playerDrawX, playerDrawY, player.width, player.height);
        }

        // Dibujar puntaje
        ctx.font = '20px Arial';
        ctx.lineWidth = 2;
        ctx.fillStyle = '#fff';
        ctx.strokeStyle = '#000';
        const scoreText = "Score: " + score;
        ctx.strokeText(scoreText, 10, 30);
        ctx.fillText(scoreText, 10, 30);

        // Mensajes de game over / victoria
        if (gameState === 'gameover') {
          ctx.font = '30px Arial';
          ctx.fillStyle = 'red';
          ctx.fillText('GAME OVER', canvas.width/2 - 80, canvas.height/2);
        } else if (gameState === 'victory') {
          ctx.font = '30px Arial';
          ctx.fillStyle = 'lime';
          ctx.fillText('YOU WIN!', canvas.width/2 - 60, canvas.height/2);
        }
      }

      // Manejo de entradas (teclado)
      let leftPressed = false, rightPressed = false;
      window.addEventListener('keydown', function(e) {
        if (gameState !== 'running') return;  // solo cuando juego activo
        const key = e.key;
        if (key === 'ArrowLeft' || key === 'a' || key === 'A') {
          leftPressed = true;
        }
        if (key === 'ArrowRight' || key === 'd' || key === 'D') {
          rightPressed = true;
        }
        if ((key === 'ArrowUp' || key === 'w' || key === 'W' || key === ' ') && player.grounded) {
          // Saltar
          player.vy = -player.jumpForce;
          player.grounded = false;
        }
      });
      window.addEventListener('keyup', function(e) {
        const key = e.key;
        if (key === 'ArrowLeft' || key === 'a' || key === 'A') {
          leftPressed = false;
        }
        if (key === 'ArrowRight' || key === 'd' || key === 'D') {
          rightPressed = false;
        }
      });

      // Manejo de entradas (controles táctiles y mouse)
      const leftBtn = document.getElementById('leftBtn');
      const rightBtn = document.getElementById('rightBtn');
      const jumpBtn = document.getElementById('jumpBtn');

      // Eventos táctiles
      leftBtn.addEventListener('touchstart', function(e) {
        e.preventDefault();
        leftPressed = true;
      });
      leftBtn.addEventListener('touchend', function(e) {
        e.preventDefault();
        leftPressed = false;
      });
      rightBtn.addEventListener('touchstart', function(e) {
        e.preventDefault();
        rightPressed = true;
      });
      rightBtn.addEventListener('touchend', function(e) {
        e.preventDefault();
        rightPressed = false;
      });
      jumpBtn.addEventListener('touchstart', function(e) {
        e.preventDefault();
        if (player.grounded) {
          player.vy = -player.jumpForce;
          player.grounded = false;
        }
      });
      jumpBtn.addEventListener('touchend', function(e) {
        e.preventDefault();
        // no es necesario poner jumpPressed = false porque el salto es instantáneo
      });

      // Eventos de mouse (para test en PC)
      leftBtn.addEventListener('mousedown', function(e) {
        e.preventDefault();
        leftPressed = true;
      });
      leftBtn.addEventListener('mouseup', function(e) {
        e.preventDefault();
        leftPressed = false;
      });
      rightBtn.addEventListener('mousedown', function(e) {
        e.preventDefault();
        rightPressed = true;
      });
      rightBtn.addEventListener('mouseup', function(e) {
        e.preventDefault();
        rightPressed = false;
      });
      jumpBtn.addEventListener('mousedown', function(e) {
        e.preventDefault();
        if (player.grounded) {
          player.vy = -player.jumpForce;
          player.grounded = false;
        }
      });
      jumpBtn.addEventListener('mouseup', function(e) {
        e.preventDefault();
      });

      // Iniciar juego al clicar el botón de inicio
      document.getElementById('startBtn').addEventListener('click', startGame);
    })();
  </script>
</body>
</html>
