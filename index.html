<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>LittleBrett Game</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      height: 100%;
      background-color: black;
    }
    canvas {
      display: block;
      width: 100vw;
      height: 100vh;
    }
    #startButton {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 25vw;
      max-width: 300px;
      z-index: 10;
      cursor: pointer;
    }
  </style>
</head>
<body>

  <img id="startButton" src="btn_start.png" alt="Start">
  <canvas id="gameCanvas"></canvas>
  <img id="invokeButton" src="invoke_btn.png" style="display: none; position: absolute; bottom: 20px; left: 20px; width: 70px; cursor: pointer; z-index: 20;">

  <script>
    const startButton = document.getElementById('startButton');
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    const bgForest = new Image(); bgForest.src = 'bg_forest.png';
    const brettIdle = new Image(); brettIdle.src = 'brett_idle.png';
    const brettWalk = new Image(); brettWalk.src = 'brett_walk1.png';
    const brettJump = new Image(); brettJump.src = 'brett_jump.png';
    const brettFall = new Image(); brettFall.src = 'brett_fall.png';
    const brettDown = new Image(); brettDown.src = 'brett_down.png';
    const gameOverImg = new Image(); gameOverImg.src = 'gameover.png';
    const retryBtn = new Image(); retryBtn.src = 'retry_btn.png';
    const bullFire = new Image(); bullFire.src = 'bull_fire.png';
    const heartFull = new Image(); heartFull.src = 'heart_full.png';
    const heartEmpty = new Image(); heartEmpty.src = 'heart_empty.png';

    const explosionImg = new Image(); explosionImg.src = 'explosion.png';

    const invokeButton = document.getElementById('invokeButton');

    let score = 0;
    let bullCharges = 0;
    let bullActive = false;
    let bullX = -200;
    let bullSpeed = 15;
    let gameStarted = false;
    let gameOver = false;
    let showRetry = false;

    let brettX = 400, brettY = 380, velocityY = 0;
    let isJumping = false, moveLeft = false, moveRight = false;
    let isInvincible = false, invincibilityTimer = 0;
    let lives = 5;

    const enemy = {
      x: 400, y: 460, width: 50, height: 60, speed: 2.5, direction: 1,
      alive: true, exploding: false, explosionTimer: 0,
      img: new Image()
    };
    enemy.img.src = 'enemy1.png';

    const platforms = [];
    const platformCount = 50;
    let px = 200, py = 400, dir = -1;
    for (let i = 0; i < platformCount; i++) {
      const isLog = i % 5 === 0;
      platforms.push({
        x: px,
        y: py,
        width: 120,
        height: 20,
        img: isLog ? "log.png" : "Platform_small.png",
        type: isLog ? "log" : "normal",
        triggered: false,
        timer: 0
      });
      px += 130;
      py += dir * 40;
      if (i % 4 === 0) dir *= -1;
      if (py < 200) py = 200;
      if (py > 450) py = 450;
    }

    const platformImages = {};
    for (const p of platforms) {
      if (!platformImages[p.img]) {
        platformImages[p.img] = new Image();
        platformImages[p.img].src = p.img;
      }
    }

    const coins = [];
    const coinTypes = ['coin', 'eth', 'btc'];
    for (let i = 0; i < platforms.length; i++) {
      const p = platforms[i];
      const type = coinTypes[i % coinTypes.length];
      const value = type === 'btc' ? 50 : type === 'eth' ? 30 : 20;
      coins.push({
        x: p.x + (p.width / 2) - 15,
        y: p.y - 30,
        type: type,
        value: value,
        collected: false
      });
    }

    const coinImages = {
      coin: new Image(),
      eth: new Image(),
      btc: new Image()
    };
    coinImages.coin.src = 'coin.png';
    coinImages.eth.src = 'eth.png';
    coinImages.btc.src = 'btc.png';

    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      if (gameStarted) drawGame();
    }
    window.addEventListener('resize', resizeCanvas);

    startButton.onclick = () => {
      gameStarted = true;
      startButton.style.display = 'none';
      resizeCanvas();
      gameLoop();
    };

    function checkInvokeButton() {
      invokeButton.style.display = bullCharges > 0 ? 'block' : 'none';
    }

    invokeButton.onclick = () => {
      if (!bullActive && bullCharges > 0) {
        bullActive = true;
        bullX = -200;
        bullCharges--;
      }
    };

    function drawGame() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.drawImage(bgForest, 0, 0, canvas.width, canvas.height);

      for (const p of platforms) {
        if (p.type === 'log' && p.triggered && p.timer > 120) continue;
        ctx.drawImage(platformImages[p.img], p.x, p.y, p.width, p.height);
      }

      for (const c of coins) {
        if (!c.collected) {
          ctx.drawImage(coinImages[c.type], c.x, c.y, 30, 30);
        }
      }

      ctx.fillStyle = 'white';
      ctx.font = '24px Arial';
      ctx.fillText(`Score: ${score}`, 20, 40);

      const heartSize = 30;
      for (let i = 0; i < 5; i++) {
        const img = i < lives ? heartFull : heartEmpty;
        ctx.drawImage(img, canvas.width - (i + 1) * (heartSize + 10), 10, heartSize, heartSize);
      }

      const brettW = canvas.width * 0.1;
      const brettH = brettW;
      let currentSprite = brettIdle;
      if (isJumping) currentSprite = velocityY < 0 ? brettJump : brettFall;
      else if (moveLeft || moveRight) currentSprite = brettWalk;

      if (!isInvincible || Math.floor(invincibilityTimer / 10) % 2 === 0)
        ctx.drawImage(currentSprite, brettX, brettY, brettW, brettH);

      if (bullActive) {
        const bullY = canvas.height - 140;
        ctx.drawImage(bullFire, bullX, bullY, 150, 100);
      }

      if (enemy.alive) {
        ctx.drawImage(enemy.img, enemy.x, enemy.y, enemy.width, enemy.height);
      } else if (enemy.exploding && enemy.explosionTimer > 0) {
        ctx.drawImage(explosionImg, enemy.x, enemy.y, 100, 100);
      }

      if (gameOver) {
        ctx.drawImage(gameOverImg, (canvas.width - 400) / 2, (canvas.height - 200) / 2, 400, 100);
        if (showRetry) {
          ctx.drawImage(retryBtn, (canvas.width - 200) / 2, (canvas.height - 80) / 2 + 100, 200, 80);
        }
      }
    }

    function gameLoop() {
      const speed = 5, gravity = 1.2;
      const brettW = canvas.width * 0.1;
      const brettH = brettW;

      if (moveLeft) brettX -= speed;
      if (moveRight) brettX += speed;
      brettX = Math.max(0, Math.min(canvas.width - brettW, brettX));

      velocityY += gravity;
      brettY += velocityY;

      let onPlatform = false;
      for (const p of platforms) {
        if (p.type === 'log' && p.triggered) {
          p.timer++;
          if (p.timer > 360) {
            p.triggered = false;
            p.timer = 0;
          }
          if (p.timer > 120) continue;
        }

        const onTop = brettX + brettW > p.x && brettX < p.x + p.width &&
                      brettY + brettH >= p.y && brettY + brettH <= p.y + 20 && velocityY >= 0;
        if (onTop) {
          brettY = p.y - brettH;
          velocityY = 0;
          isJumping = false;
          onPlatform = true;
          if (p.type === 'log' && !p.triggered) {
            p.triggered = true;
            p.timer = 0;
          }
        }
      }

      if (!onPlatform && brettY >= canvas.height - brettH - 20) {
        brettY = canvas.height - brettH - 20;
        velocityY = 0;
        isJumping = false;
        onPlatform = true;
      }
      if (!onPlatform) isJumping = true;

      for (const c of coins) {
        if (!c.collected) {
          const colX = brettX + brettW > c.x && brettX < c.x + 30;
          const colY = brettY + brettH > c.y && brettY < c.y + 30;
          if (colX && colY) {
            c.collected = true;
            const prev = score;
            score += c.value;
            const chargesBefore = Math.floor(prev / 100);
            const chargesAfter = Math.floor(score / 100);
            bullCharges += chargesAfter - chargesBefore;
          }
        }
      }

      if (enemy.alive && !isInvincible && !gameOver) {
        const colX = brettX + brettW > enemy.x && brettX < enemy.x + enemy.width;
        const colY = brettY + brettH > enemy.y && brettY < enemy.y + enemy.height;
        if (colX && colY) {
          lives--;
          isInvincible = true;
          invincibilityTimer = 120;
          if (lives <= 0) {
            gameOver = true;
            setTimeout(() => showRetry = true, 2000);
          }
        }
      }

      if (bullActive) {
        bullX += bullSpeed;
        if (enemy.alive) {
          const bullY = canvas.height - 140;
          const colX = bullX + 150 > enemy.x && bullX < enemy.x + enemy.width;
          const colY = bullY + 100 > enemy.y && bullY < enemy.y + enemy.height;
          if (colX && colY) {
            enemy.exploding = true;
            enemy.explosionTimer = 90;
            enemy.alive = false;
          }
        }
      }
      if (bullX > canvas.width) {
        bullActive = false;
        bullX = -200;
      }
      if (enemy.exploding && enemy.explosionTimer > 0) enemy.explosionTimer--;

      if (isInvincible) {
        invincibilityTimer--;
        if (invincibilityTimer <= 0) isInvincible = false;
      }

      checkInvokeButton();
      drawGame();
      requestAnimationFrame(gameLoop);
    }

    window.addEventListener('keydown', (e) => {
      if (!gameStarted) return;
      if (e.key === 'ArrowLeft' || e.key === 'a') moveLeft = true;
      if (e.key === 'ArrowRight' || e.key === 'd') moveRight = true;
      if ((e.key === ' ' || e.key === 'w') && !isJumping) {
        isJumping = true;
        velocityY = -18;
      }
    });
    window.addEventListener('keyup', (e) => {
      if (e.key === 'ArrowLeft' || e.key === 'a') moveLeft = false;
      if (e.key === 'ArrowRight' || e.key === 'd') moveRight = false;
    });

    canvas.addEventListener('click', function(e) {
      if (!showRetry) return;
      const rect = canvas.getBoundingClientRect();
      const clickX = e.clientX - rect.left;
      const clickY = e.clientY - rect.top;
      const retryW = 200, retryH = 80;
      const retryX = (canvas.width - retryW) / 2;
      const retryY = (canvas.height - retryH) / 2 + 100;
      if (clickX >= retryX && clickX <= retryX + retryW && clickY >= retryY && clickY <= retryY + retryH) {
        location.reload();
      }
    });
  </script>
</body>
</html>
