<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>LittleBrett Game</title>
  <style>
    canvas { background: #000; display: block; margin: auto; }
    body { margin: 0; overflow: hidden; }
  </style>
</head>
<body>
<canvas id="gameCanvas" width="800" height="400"></canvas>

<script>
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");

const gravity = 0.5;
let isJumping = false;
let isFalling = false;
let isGameOver = false;
let showGameOverScreen = false;

const player = {
  x: 50,
  y: 300,
  width: 50,
  height: 50,
  color: "blue",
  vy: 0,
  jumpForce: -12,
  grounded: false,
  invincible: false,
  invincibilityTimer: 0,
  health: 5
};

const enemy = {
  x: 400,
  y: 350,
  width: 40,
  height: 40,
  speed: 2,
  direction: 1,
  alive: true
};

const retryButton = {
  x: canvas.width / 2 - 75,
  y: canvas.height / 2 + 50,
  width: 150,
  height: 50,
  image: new Image()
};
retryButton.image.src = "retry_btn.png";

const gameOverImage = new Image();
gameOverImage.src = "gameover.png";

const heartFull = new Image();
heartFull.src = "heart_full.png";

const heartEmpty = new Image();
heartEmpty.src = "heart_empty.png";

const brettDown = new Image();
brettDown.src = "brett_down.png";

const platforms = [];
for (let i = 0; i < 50; i++) {
  const x = i * 100 + 100;
  const y = 250 + 50 * Math.sin(i * 0.5);
  platforms.push({ x, y, width: 80, height: 10 });
}

const keys = {};
document.addEventListener("keydown", e => keys[e.key] = true);
document.addEventListener("keyup", e => keys[e.key] = false);

canvas.addEventListener("click", function (e) {
  if (!isGameOver) return;

  const rect = canvas.getBoundingClientRect();
  const clickX = e.clientX - rect.left;
  const clickY = e.clientY - rect.top;

  if (
    clickX >= retryButton.x &&
    clickX <= retryButton.x + retryButton.width &&
    clickY >= retryButton.y &&
    clickY <= retryButton.y + retryButton.height
  ) {
    location.reload();
  }
});

function checkCollision(a, b) {
  return (
    a.x < b.x + b.width &&
    a.x + a.width > b.x &&
    a.y < b.y + b.height &&
    a.y + a.height > b.y
  );
}

function drawPlayer() {
  ctx.fillStyle = player.color;
  ctx.fillRect(player.x, player.y, player.width, player.height);
}

function drawEnemy() {
  if (enemy.alive) {
    ctx.fillStyle = "red";
    ctx.fillRect(enemy.x, enemy.y, enemy.width, enemy.height);
  }
}

function drawPlatforms() {
  ctx.fillStyle = "green";
  for (let p of platforms) {
    ctx.fillRect(p.x, p.y, p.width, p.height);
  }
}

function drawHearts() {
  const heartSize = 32;
  for (let i = 0; i < 5; i++) {
    const img = i < player.health ? heartFull : heartEmpty;
    ctx.drawImage(img, canvas.width - (i + 1) * (heartSize + 5) - 10, 10, heartSize, heartSize);
  }
}

function handleDamage() {
  if (player.invincible || !enemy.alive) return;

  if (checkCollision(player, enemy)) {
    player.health -= 1;
    player.invincible = true;
    player.invincibilityTimer = 60;

    if (player.health <= 0) {
      isGameOver = true;
      setTimeout(() => {
        showGameOverScreen = true;
      }, 2000);
    }
  }
}

function updatePlayer() {
  if (keys["ArrowLeft"]) player.x -= 5;
  if (keys["ArrowRight"]) player.x += 5;

  if (keys[" "] && player.grounded) {
    player.vy = player.jumpForce;
    player.grounded = false;
  }

  player.vy += gravity;
  player.y += player.vy;

  player.grounded = false;
  for (let p of platforms) {
    if (
      player.y + player.height >= p.y &&
      player.y + player.height <= p.y + 10 &&
      player.x + player.width > p.x &&
      player.x < p.x + p.width
    ) {
      player.y = p.y - player.height;
      player.vy = 0;
      player.grounded = true;
    }
  }

  if (player.invincible) {
    player.invincibilityTimer--;
    if (player.invincibilityTimer <= 0) {
      player.invincible = false;
    }
  }
}

function updateEnemy() {
  if (!enemy.alive) return;

  enemy.x += enemy.speed * enemy.direction;

  const minX = canvas.width * 0.2;
  const maxX = canvas.width * 0.8 - enemy.width;

  if (enemy.x <= minX) enemy.direction = 1;
  if (enemy.x >= maxX) enemy.direction = -1;
}

function gameLoop() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  if (!isGameOver) {
    updatePlayer();
    updateEnemy();
    handleDamage();
    drawPlatforms();
    drawEnemy();
    drawPlayer();
    drawHearts();
  } else {
    if (!showGameOverScreen) {
      ctx.drawImage(brettDown, player.x, player.y, player.width, player.height);
    } else {
      ctx.drawImage(gameOverImage, canvas.width / 2 - 150, canvas.height / 2 - 100, 300, 100);
      ctx.drawImage(retryButton.image, retryButton.x, retryButton.y, retryButton.width, retryButton.height);
    }
  }

  requestAnimationFrame(gameLoop);
}

gameLoop();
</script>
</body>
</html>
